/// @file
/// @copyright Copyright 2024 CNRS INRIA

#include <eigenpy/eigenpy.hpp>
#include <eigenpy/variant.hpp>

#cmakedefine TEST_TYPE @TEST_TYPE@
#define VARIANT TEST_TYPE

namespace bp = boost::python;

struct V1 {
  int v;
};
struct V2 {
  char v;
};
typedef VARIANT<V1, V2> MyVariant;

template <typename Variant>
struct MyVariantNoneHelper {};

template <typename... Alternatives>
struct MyVariantNoneHelper<boost::variant<Alternatives...> > {
  typedef VARIANT<boost::blank, Alternatives...> type;
};

#ifdef EIGENPY_WITH_CXX17_SUPPORT
template <typename... Alternatives>
struct MyVariantNoneHelper<std::variant<Alternatives...> > {
  typedef VARIANT<std::monostate, Alternatives...> type;
};
#endif

typedef typename MyVariantNoneHelper<VARIANT<V1> >::type MyVariantNone;

typedef VARIANT<int, double> MyVariantArithmetic;

// There is a conversion conflict between int and bool
typedef VARIANT<bool, double> MyVariantBool;

MyVariant make_variant() { return V1(); }

MyVariantNone make_variant_none() { return MyVariantNone(); }

MyVariantArithmetic make_variant_arithmetic() { return MyVariantArithmetic(); }

MyVariantBool make_variant_bool() { return MyVariantBool(); }

struct VariantHolder {
  MyVariant variant;
};

struct VariantNoneHolder {
  MyVariantNone variant;
};

struct VariantArithmeticHolder {
  MyVariantArithmetic variant;
};

struct VariantBoolHolder {
  MyVariantBool variant;
};

BOOST_PYTHON_MODULE(@MODNAME@) {
  using namespace eigenpy;

  enableEigenPy();

  bp::class_<V1>("V1", bp::init<>()).def_readwrite("v", &V1::v);
  bp::class_<V2>("V2", bp::init<>()).def_readwrite("v", &V2::v);

  typedef eigenpy::VariantConverter<MyVariant> Converter;
  Converter::registration();

  bp::def("make_variant", make_variant);

  boost::python::class_<VariantHolder>("VariantHolder", bp::init<>())
      .add_property("variant",
                    bp::make_getter(&VariantHolder::variant,
                                    Converter::return_internal_reference()),
                    bp::make_setter(&VariantHolder::variant));

  typedef eigenpy::VariantConverter<MyVariantNone> ConverterNone;
  ConverterNone::registration();
  bp::def("make_variant_none", make_variant_none);

  boost::python::class_<VariantNoneHolder>("VariantNoneHolder", bp::init<>())
      .add_property("variant",
                    bp::make_getter(&VariantNoneHolder::variant,
                                    ConverterNone::return_internal_reference()),
                    bp::make_setter(&VariantNoneHolder::variant));

  typedef eigenpy::VariantConverter<MyVariantArithmetic> ConverterArithmetic;
  ConverterArithmetic::registration();
  bp::def("make_variant_arithmetic", make_variant_arithmetic);

  boost::python::class_<VariantArithmeticHolder>("VariantArithmeticHolder",
                                                 bp::init<>())
      .add_property(
          "variant",
          bp::make_getter(&VariantArithmeticHolder::variant,
                          ConverterArithmetic::return_internal_reference()),
          bp::make_setter(&VariantArithmeticHolder::variant));

  typedef eigenpy::VariantConverter<MyVariantBool> ConverterBool;
  ConverterBool::registration();
  bp::def("make_variant_bool", make_variant_bool);

  boost::python::class_<VariantBoolHolder>("VariantBoolHolder",
                                                 bp::init<>())
      .add_property(
          "variant",
          bp::make_getter(&VariantBoolHolder::variant,
                          ConverterBool::return_internal_reference()),
          bp::make_setter(&VariantBoolHolder::variant));
}
